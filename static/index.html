<!DOCTYPE html>
<html>
<head>
<title>Camera Crowd</title>
<style>
  body { margin: 0; }
  canvas { width: 100%; height: 100% }
</style>
</head>
<body>
<script src="js/three.min.js"></script>
<script src="js/PointerLockControls.js"></script>
<script src="js/tween.min.js"></script>
<script src="js/StereoEffect.js"></script>
<script src="js/DeviceOrientationControls.js"></script>
<script src="js/OrbitControls.js"></script>
<script>
  var constructPerspective = false;

  var scene = new THREE.Scene();
  var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.001, 100000);
  
  var renderer = new THREE.WebGLRenderer();
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  ptr_controls = new THREE.PointerLockControls(camera);
  ptr_controls.enabled = true;
  ptr_controls.getObject().position.y = 0;
  scene.add(ptr_controls.getObject());

  var effect = renderer;
  var dev_controls = null;

  function fullscreen() {
    var container = document.body;
    if (container.requestFullscreen) {
      container.requestFullscreen();
    } else if (container.msRequestFullscreen) {
      container.msRequestFullscreen();
    } else if (container.mozRequestFullScreen) {
      container.mozRequestFullScreen();
    } else if (container.webkitRequestFullscreen) {
      container.webkitRequestFullscreen();
    }
  }

  function setOrientationControls(e) {
    if (!e.alpha) return;
    effect = new THREE.StereoEffect(renderer);
    effect.setSize(window.innerWidth, window.innerHeight);
    dev_controls = new THREE.DeviceOrientationControls(camera, true);
    dev_controls.connect();
    dev_controls.update();
    renderer.domElement.addEventListener('click', fullscreen, false);
    window.removeEventListener('deviceorientation', setOrientationControls, true);
  }
  window.addEventListener('deviceorientation', setOrientationControls, true);


  var geometry = new THREE.BoxGeometry(100, 100, 100);

  textureCube = THREE.ImageUtils.loadTextureCube([
    'img/pos-x.jpg',
    'img/neg-x.jpg',
    'img/pos-y.jpg',
    'img/neg-y.jpg',
    'img/pos-z.jpg',
    'img/neg-z.jpg'
  ]);
  textureCube.format = THREE.RGBFormat;

  var shader = THREE.ShaderLib['cube'];
  var uniforms = THREE.UniformsUtils.clone(shader.uniforms);
  uniforms['tCube'].value = textureCube;
  var material = new THREE.ShaderMaterial( {
    fragmentShader: shader.fragmentShader,
    vertexShader: shader.vertexShader,
    uniforms: uniforms,
    depthWrite: false,
    side: THREE.BackSide
  });

  var cube = new THREE.Mesh(geometry, material);
  scene.add(cube);

  function render() {
    if (dev_controls) dev_controls.update()
    effect.render(scene, camera);
  }
  window.addEventListener('resize', function() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    effect.setSize(window.innerWidth, window.innerHeight);
    render();
  }, false);

  function animate() {
    TWEEN.update();
    render();
    requestAnimationFrame(animate);
  }

  var textureLoader = new THREE.TextureLoader();

  var source = new EventSource("/events");
  source.onmessage = function(event) {
    var messages = JSON.parse(event.data);
    console.log("Got messages", messages);
    for (var ii = 0; ii < messages.length; ii++) {
      (function(message, delay) {
        window.setTimeout(function() {
          var planeHolder = new THREE.Object3D();
          if (constructPerspective) {
              planeHolder.matrixAutoUpdate = false;
              planeHolder.matrix.set.apply(planeHolder.matrix, message.json);
              scene.add(planeHolder);
          } else {
              planeHolder.position.x = 1;
              planeHolder.rotation.y = -Math.PI / 2;
              scene.add(planeHolder);
          }

          textureLoader.load(message.url, function(texture) {
            texture.minFilter = THREE.LinearFilter;
            if (constructPerspective) {
                var geometry = new THREE.PlaneBufferGeometry(2, 2 * texture.image.height / texture.image.width);
            } else {
                var geometry = new THREE.PlaneGeometry(2, 2 * texture.image.height / texture.image.width);
                console.log(geometry.vertices);
                for (var ii = 0; ii < 4; ii++) {
                  geometry.vertices[ii].x = message.json[ii][0];
                  geometry.vertices[ii].y = message.json[ii][1];
                  geometry.vertices[ii].z = 0;
                }
                geometry.verticesNeedUpdate = true;
            }
            var material = new THREE.MeshBasicMaterial({map: texture, side: THREE.DoubleSide, transparent: true});
            var plane = new THREE.Mesh(geometry, material);
            planeHolder.add(plane);
  
            // Animate
            new TWEEN.Tween({scale: 0, z: 2}).to({scale: 1, z: 0}, 2000)
            .easing(TWEEN.Easing.Elastic.Out)
            .onUpdate(function() {
              plane.scale.x = this.scale;
              plane.scale.y = this.scale;
              plane.scale.z = this.scale;
              plane.position.z = this.z;
            }).chain(new TWEEN.Tween({alpha: 1}).to({alpha: 0}, 1000)
              .easing(TWEEN.Easing.Linear.None)
              .onUpdate(function() {
                material.opacity = this.alpha;
              }).onComplete(function() {
                scene.remove(planeHolder);
              }))
            .start();
          });
        }, delay);
      })(messages[ii], (ii + Math.random()) * 3000);
    }
  };
  source.onerror = function() {
    window.setTimeout(function() {
      source.onmessage({data: JSON.stringify(
        [
{url: "../photos/1", id: 1, json:
[[0.07729315757751465, 0.3681415915489197], [1.7906322479248047, 0.3627665638923645], [0.18581092357635498, -1.2419912815093994], [1.8534884452819824, -1.0607545375823975]]
},
{url: "../neg-x.jpg", id: 1, json:
[[-0.9999999999999993, 0.9999999999999987], [1.0, 1.0], [-0.9999999999999987, -1.0], [1.0, -1.0]]
},
{url: "../neg-x-scaled.jpg", id: 1, json:
[[-0.9968051335308701, 0.9966263277456164], [3.008164405822754, 1.0016081765061244], [-1.0009997757151723, -3.0135130882263184], [3.0301027297973633, -3.0307154655456543]]
},
{url: "../neg-x-cropped.jpg", id: 1, json:
[[0.0008351802825927734, 0.49986928701400757], [0.9979162216186523, 0.49937117099761963], [-0.0017009377479553223, -0.5014166831970215], [0.9992722272872925, -0.49932312965393066]]
},
{url: "../neg-x-rotated.jpg", id: 1, json:
[[-0.35476118326187134, 0.00038808584213256836], [1.054525375366211, 1.3989683985710144], [1.0637104511260986, -1.4171786308288574], [2.453383684158325, 0.0034925341606140137]]
},
{url: "../neg-x-perspective.jpg", id: 1, json:
[[-0.5999115109443665, 1.4722099900245667], [1.3318262100219727, 0.12777751684188843], [-0.5328179001808167, -3.933413028717041], [1.3075733184814453, -1.0828301906585693]]
},
        ])});
    }, 1000);
  };

  animate();
</script>
</body>
</html>
